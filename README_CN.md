# 节点序列化工具


## 描述

### 主要解决的问题

- 快速获取关键节点及其节点上的挂载的组件，无需拖拽赋值，无需要代码中定义变量或节点查找。
- 模板节点的实例创建及回收管理，方便背包、列表等功能的开发。
- 节点和容器支持嵌套，可方便实现节点的分级管理。
- 尤其适用于每个GameObject或prefab资源中的节点结构都不相同且对其中的大量节点及其组件有较多操作的情况，如游戏UI界面。

### 名词解释

#### 容器

容器为位于特定父节点上的一个组件（Component），其代码由此工具自动生成。该组件用于存储对于该容器中所有关键节点及其节点组件的引用。容器内包含的关键节点均为容器所在节点的子节点。

#### 根容器

其容器节点不被其他容器节点引用。脚本的类型名称与容器节点的名称相同，故根容器节点的节点名称应满足类型名称的命名规范。

#### 子容器

特殊的关键节点（节点名称以"i\_"开头）上挂载的容器组件，具有与容器相同的特性。

子容器脚本的类型名为其所在父容器的类型名称与节点名称去掉"i\_"的部分的组合，并以下划线分隔，故子容器节点名称中除"i\_"部分名的名称应满足类型名称的命名规范。

#### 节点

即容器中的每一个GameObject，节点与节点可组成具有树状的层级结构。

#### 关键节点

位于容器的子节点中，名称以"m\_"或以"i\_"开头的节点。以"m\_"开头的节点是普通关键节点，关键节点及其组件将被该节点所在的容器引用；以"i\_"开头的节点为子容器节点，除包含所有普通关键的特性外，此工具还将在此节点上为其挂载容器脚本，用于存储该容器节点下所有对于关键节点及其节点组件的引用。

在节点的所有父节点中，与其距离最近的带有容器组件的节点为该节点的容器节点。

非关键节点在本工具插件中将被完全忽略，本文档中后续所有节点均指关键节点。

节点名称除"m\_"或"i\_"以外的部分将被用作字段名称或属性名称，所以节点名称除"m\_"或"i\_"以外的部分应满足变量的命名规则。

#### 节点组件

逻辑功能开发时挂载于节点上的功能组件，如UnityEngine.UI.Image、UnityEngine.UI.Text等，将与节点一起被其所在的容器引用。

仅被支持类型的组件才会被引用，除部分已经支持的组件外，也可以通过少量代码将任意组件类型进行集成，以使该组件会被引用。



## 操作步骤

### 为GameObject新增或更新容器

1. 根据需求创建或编辑资源，合理规划其关键节点及子容器，并为其取合适的名称。
2. 在Project容器中选择prefab右键点击GreatClock -> Serialize Tools -> C# Serialized Component打开操作界面，或通过菜单栏GreatClock -> Serialize Tools -> C# Serialized Component打开操作界面，并将要操作的GameObject或prefab拖拽至界面中Game Object处。
3. 检查并修改用于存放生成代码的目录及代码使用的命名空间。
4. 在操作界面中检查节点、节点组件。
5. 检查容器组件的基类以及类型中partial类和public属性的定义。
6. 点击生成并挂载，工具将自动生成或更新容器脚本，并将容器与其关键节点及组件建立引用。
7. 编写运行时代码加载资源并获取根容器实例，或利用partial类编写同名类中逻辑代码部分。

### 为此工具增加其他类型组件的支持

在编辑器代码中增加如下代码段，即可向此工具增加对自定义或其他组件的支持。

```c#
using GreatClock.Common.SerializeTools;

// 类名并不重要，但应运行在Unity Editor环境中
public class SerializeToolExtend {
    
    // 此Attribute为必需，方法应为static并返回包含定制化信息的SupportedTypeData实例
    // 方法名称并不重要，方便代码阅读及管理即可
    [SupportedComponentType]
	static SupportedTypeData DefineTypeMyComponent() {
        // 指定要支持组件的类型，排序优先级，界面显示组件名称，生成代码中的引用的命名空间，
        // 生成代码中组件类型名称，及组件的变量名称。后四项均可传入null以采用默认参数（自动配置）
		return new SupportedTypeData(typeof(MyComponent), 1000, null, null, null, null);
	}
    
	[SupportedComponentType]
	static SupportedTypeData DefineTypeTween() {
        // 增加此工具对MyTweenComponent组件的支持，并为此组件指定生成代码中的变量名为tween
		return new SupportedTypeData(typeof(MyTweenComponent), 1000, null, null, null, "tween");
	}
    
}
```



## 注意事项

- 自动生成的代码，不要进行手动编辑。
- 序列化脚本被prefab直接引用，无法实现序列化脚本代码的热更新，已有资源更新时节点增删和重命名将受到限制。
- 同一容器中的关键节点不可重名。
- 此工具仅会对当前规则下同名的容器及子容器进行创建或更新，不会对原有失效容器进行清理。如果将容器节点进行移动、重命名、改为非容器节点等导致容器脚本名称有修改的操作，需要手动将原容器组件及相应代码进行清理。
- 在逻辑代码中，关键节点及其组件是以容器的成员变量方式被访问，这样更方便逻辑代码对关键节点和组件的调用，但也更容易产生编译问题。此编译问题也能第一时间反应出资源的修改对代码逻辑造成的影响。
- 若使用partial类方式实现与资源对应的逻辑，建议用private属性；若仅将使其发挥容器的作用，建议使用非partial类与public属性。



## 常见问题

**问：** 重新生成代码后，编译错误如何处理？

**答：** 产生编译错误后，无法保证容器对节点的正确引用，需要在解决编译问题后重新执行“生成并挂载”。产生编译错误的情况会有很多，如：非法的节点或容器名称、节点删除、节点改名、组件删除等。其修复方法为修正容器或节点名称、修改逻辑代码，以修正代码中对已经不存在的节点或组件的引用。

------

**问：** 容器和生成代码的对应关系是什么样的？

**答：** 在此工具中，每一个容器对应一个代码文件，根容器的代码文件名和类名均为根容器节点的节点名称，子容器代码文件的文件名和类名为父容易的类名+'\_'+该子容器节点的节点名。同一资源的所有生成的代码都存在于同一个文件夹中。

------

**问：** 生成的代码存储目录是怎么管理的？

**答：** 每一个资源都可以独立指定其生成代码存放目录，但并没有进行资源和目录之间对应关系的管理。在管理界面打开一个资源时，工具会自动查找与之匹配的生成代码，并将此资源所有容器类型的基类、partial类和public属性相关的配置一并从代码中读取，故除资源对应的生成代码的存储目录之外，相关的配置也都是通过已经存在的代码进行存储的。

------

**问：** 对于背包的格子、滚动列表中的条目，是怎么编辑和使用的？

**答：** 通常这类内容都是在运行时同一父节点下存在大量相同结构的子节点，且每一个节点控制各自相同节点结构中的内容。在编辑器中编辑时，仅需要编辑其模板即可，并在父节点使用Layout或自行指定其排列规则。同时将此模板设置为子容器，以保证运行时创建多份时，每一个实例都可以独立控制。在运行时，推荐在初始化时将此模板隐藏，即获取到该子容器的gameObject并调用其SetActive(false)方法。在填充内容时，可以通过调用节点的GetInstance()方法获取该模板的实例，并向其填充内容，记得调用获取到的实例的gameObject的SetActive(true)。在刷新或重新填充时，先将所有实例内容清空，并通过子容器节点的CacheInstance()方法将所有之前获取到的实例做为参数逐个回收，以保证模板的实例可以有效复用。

